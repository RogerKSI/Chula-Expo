<!-- Libery -->
<link rel="import" href="../../staff/bower_components/polymer/polymer.html">
<!-- Web Component -->
<link rel="import" href="../../staff/bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../../staff/bower_components/app-layout/app-scroll-effects/app-scroll-effects.html">
<link rel="import" href="../../staff/bower_components/app-layout/app-scroll-effects/effects/waterfall.html">
<link rel="import" href="../../staff/bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="bottom-prefab">
  <template>
    <style include="shared-styles">
      :host {
        pointer-events: none;
        position: relative;
        display: block;
        transition-timing-function: linear;
        transition-property: -webkit-transform;
        transition-property: transform;
        width: 100%;
      }

      :host::before {
        position: absolute;
        right: 0px;
        bottom: -5px;
        left: 0px;
        width: 100%;
        height: 5px;
        content: "";
        transition: opacity 0.4s;
        pointer-events: none;
        opacity: 0;
        box-shadow: inset 0px 5px 6px -3px rgba(0, 0, 0, 0.4);
        will-change: opacity;
        @apply(--app-header-shadow);
      }

      :host {
        position: fixed;
        bottom: 20px;
      }
      
      #addIcon {
        pointer-events: visible;
        float: right;
        @apply(--shadow-elevation-8dp);
      }
    </style>
    <div class="container">
      <paper-fab id="addIcon" icon="add" on-tap="_onClick"></paper-fab>
    </div>
  </template>
  <script>
    Polymer({
      is: 'bottom-prefab',

      behaviors: [
        Polymer.AppScrollEffectsBehavior,
        Polymer.IronResizableBehavior,
      ],

      properties: {
        targetUrl: String,
        effects: {
          type: String,
          value: '',
        },
        reveals: {
          type: Boolean,
          value: false
        },
        fixed: {
          type: Boolean,
          value: false
        },
        condenses: {
          type: Boolean,
          value: false
        },
      },
      
      observers: [
        'resetLayout(isAttached, condenses, fixed)'
      ],

      listeners: {
        'iron-resize': '_resizeHandler'
      },

      _height: 0,
      _dHeight: 0,
      _stickyElTop: 0,
      _stickyEl: null,
      _top: 0,
      _progress: 0,

      _wasScrollingDown: false,
      _initScrollTop: 0,
      _initTimestamp: 0,
      _lastTimestamp: 0,
      _lastScrollTop: 0,

      get _maxHeaderTop() {
        return this.fixed ? this._dHeight : this._height + 10;
      },

      _onClick: function() {
        document.querySelector('chulaexpo-staff-app').set('route.path', this.targetUrl);
      },

      _getStickyEl: function() {
        /** @type {HTMLElement} */
        var stickyEl;
        var nodes = Polymer.dom(this.$.content).getDistributedNodes();
        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].nodeType === Node.ELEMENT_NODE) {
            var node = /** @type {HTMLElement} */ (nodes[i]);
            if (node.hasAttribute('sticky')) {
              stickyEl = node;
              break;
            } else if (!stickyEl) {
              stickyEl = node;
            }
          }
        }
        return stickyEl;
      },

      resetLayout: function() {
        this.debounce('_resetLayout', function() {
          // noop if the header isn't visible
          if (this.offsetWidth === 0 && this.offsetHeight === 0) {
            return;
          }
          var scrollTop = this._clampedScrollTop;
          var firstSetup = this._height === 0 || scrollTop === 0;
          var currentDisabled = this.disabled;
          this._height = this.offsetHeight;
          this._stickyEl = this._getStickyEl();
          this.disabled = true;
          // prepare for measurement
          if  (!firstSetup) {
            this._updateScrollState(0, true);
          }
          if (this._mayMove()) {
            this._dHeight = this._stickyEl ? this._height - this._stickyEl.offsetHeight : 0;
          } else {
            this._dHeight = 0;
          }
          this._stickyElTop = this._stickyEl ? this._stickyEl.offsetTop : 0;
          this._setUpEffect();
          if (firstSetup) {
            this._updateScrollState(scrollTop, true);
          } else {
            this._updateScrollState(this._lastScrollTop, true);
            this._layoutIfDirty();
          }
          // restore no transition
          this.disabled = currentDisabled;
          this.fire('app-header-reset-layout');
        });
      },

      _updateScrollState: function(scrollTop, forceUpdate) {
        var progress = 0;
        var top = 0;
        var lastTop = this._top;
        var lastScrollTop = this._lastScrollTop;
        var maxHeaderTop = this._maxHeaderTop;
        var dScrollTop = scrollTop - this._lastScrollTop;
        var absDScrollTop = Math.abs(dScrollTop);
        var isScrollingDown = scrollTop > this._lastScrollTop;
        var now = performance.now();

        if (this._mayMove()) {
          top = this._clamp(this.reveals ? lastTop + dScrollTop : scrollTop, 0, maxHeaderTop);
        }
        if (scrollTop >= this._dHeight) {
          top = this.condenses && !this.fixed ? Math.max(this._dHeight, top) : top;
          this.style.transitionDuration = '100ms';
        }
        if (this.reveals && !this.disabled && absDScrollTop < 100) {
          // set the initial scroll position
          if (now - this._initTimestamp > 300 || this._wasScrollingDown !== isScrollingDown) {
            this._initScrollTop = scrollTop;
            this._initTimestamp = now;
          }
          if (scrollTop >= maxHeaderTop) {
            // check if the header is allowed to snap
            if (Math.abs(this._initScrollTop - scrollTop) > 30 || absDScrollTop > 10) {
              if (isScrollingDown && scrollTop >= maxHeaderTop) {
                top = maxHeaderTop;
              } else if (!isScrollingDown && scrollTop >= this._dHeight) {
                top = this.condenses && !this.fixed ? this._dHeight : 0;
              }
              var scrollVelocity = dScrollTop / (now - this._lastTimestamp);
              this.style.transitionDuration = this._clamp((top - lastTop) / scrollVelocity, 0, 300) + 'ms';
            } else {
              top = this._top;
            }
          }
        }

        if (this._dHeight === 0) {
          progress = scrollTop > 0 ? 1 : 0;
        } else {
          progress = top / this._dHeight;
        }
        if (!forceUpdate) {
          this._lastScrollTop = scrollTop;
          this._top = top;
          this._wasScrollingDown = isScrollingDown;
          this._lastTimestamp = now;
        }
        if (forceUpdate || progress !== this._progress || lastTop !== top || scrollTop === 0) {
          this._progress = progress;
          this._runEffects(progress, top);
          this._transformHeader(!isScrollingDown);
        }
      },
      _mayMove: function() {
        return this.condenses || !this.fixed;
      },
      
      isOnScreen: function() {
        return this._height !== 0 && this._top < this._height;
      },
      
      _transformHeader: function(y) {
        this.translate3d(0, (y ? 0 : 100) + 'px', 0);
        if (this._stickyEl) {
          this.translate3d(0, this.condenses && y >= this._stickyElTop ?
              (Math.min(y, this._dHeight) - this._stickyElTop) + 'px' : 0,  0, this._stickyEl);
        }
      },

      _resizeHandler: function() {
        this.resetLayout();
      },

      _clamp: function(v, min, max) {
        return Math.min(max, Math.max(min, v));
      },

      getScrollState: function() {
        return { progress: this._progress, top: this._top };
      }
    });
  </script>
</dom-module>